\hypertarget{classcaffe_1_1EuclideanLossLayer}{}\section{caffe\+:\+:Euclidean\+Loss\+Layer$<$ Dtype $>$ Class Template Reference}
\label{classcaffe_1_1EuclideanLossLayer}\index{caffe\+::\+Euclidean\+Loss\+Layer$<$ Dtype $>$@{caffe\+::\+Euclidean\+Loss\+Layer$<$ Dtype $>$}}


Computes the Euclidean (L2) loss $ E = \frac{1}{2N} \sum\limits_{n=1}^N \left| \left| \hat{y}_n - y_n \right| \right|_2^2 $ for real-\/valued regression tasks.  




{\ttfamily \#include $<$euclidean\+\_\+loss\+\_\+layer.\+hpp$>$}

Inheritance diagram for caffe\+:\+:Euclidean\+Loss\+Layer$<$ Dtype $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classcaffe_1_1EuclideanLossLayer}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bfseries Euclidean\+Loss\+Layer} (const Layer\+Parameter \&param)\hypertarget{classcaffe_1_1EuclideanLossLayer_aea3a6d5454ee1a0db7cdb6c59bcfc5c8}{}\label{classcaffe_1_1EuclideanLossLayer_aea3a6d5454ee1a0db7cdb6c59bcfc5c8}

\item 
virtual void \hyperlink{classcaffe_1_1EuclideanLossLayer_a4d2df2fad6e3d04ed24df9fe6460c683}{Reshape} (const vector$<$ \hyperlink{classcaffe_1_1Blob}{Blob}$<$ Dtype $>$ $\ast$ $>$ \&bottom, const vector$<$ \hyperlink{classcaffe_1_1Blob}{Blob}$<$ Dtype $>$ $\ast$ $>$ \&top)
\begin{DoxyCompactList}\small\item\em Adjust the shapes of top blobs and internal buffers to accommodate the shapes of the bottom blobs. \end{DoxyCompactList}\item 
virtual const char $\ast$ \hyperlink{classcaffe_1_1EuclideanLossLayer_af7c7836f04594b7564b2d740ccaed559}{type} () const \hypertarget{classcaffe_1_1EuclideanLossLayer_af7c7836f04594b7564b2d740ccaed559}{}\label{classcaffe_1_1EuclideanLossLayer_af7c7836f04594b7564b2d740ccaed559}

\begin{DoxyCompactList}\small\item\em Returns the layer type. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classcaffe_1_1EuclideanLossLayer_a3c954fd7c15596fd2f59e0f79601905c}{Allow\+Force\+Backward} (const int bottom\+\_\+index) const 
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classcaffe_1_1EuclideanLossLayer_aa642f3d938b4e1d0c8b240c68ba8a856}{Forward\+\_\+cpu} (const vector$<$ \hyperlink{classcaffe_1_1Blob}{Blob}$<$ Dtype $>$ $\ast$ $>$ \&bottom, const vector$<$ \hyperlink{classcaffe_1_1Blob}{Blob}$<$ Dtype $>$ $\ast$ $>$ \&top)
\begin{DoxyCompactList}\small\item\em Computes the Euclidean (L2) loss $ E = \frac{1}{2N} \sum\limits_{n=1}^N \left| \left| \hat{y}_n - y_n \right| \right|_2^2 $ for real-\/valued regression tasks. \end{DoxyCompactList}\item 
virtual void \hyperlink{classcaffe_1_1EuclideanLossLayer_a0eddd3fca6ec788b61bc55960cbce68a}{Forward\+\_\+gpu} (const vector$<$ \hyperlink{classcaffe_1_1Blob}{Blob}$<$ Dtype $>$ $\ast$ $>$ \&bottom, const vector$<$ \hyperlink{classcaffe_1_1Blob}{Blob}$<$ Dtype $>$ $\ast$ $>$ \&top)\hypertarget{classcaffe_1_1EuclideanLossLayer_a0eddd3fca6ec788b61bc55960cbce68a}{}\label{classcaffe_1_1EuclideanLossLayer_a0eddd3fca6ec788b61bc55960cbce68a}

\begin{DoxyCompactList}\small\item\em Using the G\+PU device, compute the layer output. Fall back to \hyperlink{classcaffe_1_1EuclideanLossLayer_aa642f3d938b4e1d0c8b240c68ba8a856}{Forward\+\_\+cpu()} if unavailable. \end{DoxyCompactList}\item 
virtual void \hyperlink{classcaffe_1_1EuclideanLossLayer_afc83c3980206b9c24b5985819c13475c}{Backward\+\_\+cpu} (const vector$<$ \hyperlink{classcaffe_1_1Blob}{Blob}$<$ Dtype $>$ $\ast$ $>$ \&top, const vector$<$ bool $>$ \&propagate\+\_\+down, const vector$<$ \hyperlink{classcaffe_1_1Blob}{Blob}$<$ Dtype $>$ $\ast$ $>$ \&bottom)
\begin{DoxyCompactList}\small\item\em Computes the Euclidean error gradient w.\+r.\+t. the inputs. \end{DoxyCompactList}\item 
virtual void \hyperlink{classcaffe_1_1EuclideanLossLayer_a2a7972df719c3a49a7308e78927fc024}{Backward\+\_\+gpu} (const vector$<$ \hyperlink{classcaffe_1_1Blob}{Blob}$<$ Dtype $>$ $\ast$ $>$ \&top, const vector$<$ bool $>$ \&propagate\+\_\+down, const vector$<$ \hyperlink{classcaffe_1_1Blob}{Blob}$<$ Dtype $>$ $\ast$ $>$ \&bottom)\hypertarget{classcaffe_1_1EuclideanLossLayer_a2a7972df719c3a49a7308e78927fc024}{}\label{classcaffe_1_1EuclideanLossLayer_a2a7972df719c3a49a7308e78927fc024}

\begin{DoxyCompactList}\small\item\em Using the G\+PU device, compute the gradients for any parameters and for the bottom blobs if propagate\+\_\+down is true. Fall back to \hyperlink{classcaffe_1_1EuclideanLossLayer_afc83c3980206b9c24b5985819c13475c}{Backward\+\_\+cpu()} if unavailable. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classcaffe_1_1Blob}{Blob}$<$ Dtype $>$ {\bfseries diff\+\_\+}\hypertarget{classcaffe_1_1EuclideanLossLayer_a47ec68365879c820f9e18e456f93376a}{}\label{classcaffe_1_1EuclideanLossLayer_a47ec68365879c820f9e18e456f93376a}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Dtype$>$\\*
class caffe\+::\+Euclidean\+Loss\+Layer$<$ Dtype $>$}

Computes the Euclidean (L2) loss $ E = \frac{1}{2N} \sum\limits_{n=1}^N \left| \left| \hat{y}_n - y_n \right| \right|_2^2 $ for real-\/valued regression tasks. 


\begin{DoxyParams}{Parameters}
{\em bottom} & input \hyperlink{classcaffe_1_1Blob}{Blob} vector (length 2)
\begin{DoxyEnumerate}
\item $ (N \times C \times H \times W) $ the predictions $ \hat{y} \in [-\infty, +\infty]$
\item $ (N \times C \times H \times W) $ the targets $ y \in [-\infty, +\infty]$ 
\end{DoxyEnumerate}\\
\hline
{\em top} & output \hyperlink{classcaffe_1_1Blob}{Blob} vector (length 1)
\begin{DoxyEnumerate}
\item $ (1 \times 1 \times 1 \times 1) $ the computed Euclidean loss\+: $ E = \frac{1}{2n} \sum\limits_{n=1}^N \left| \left| \hat{y}_n - y_n \right| \right|_2^2 $
\end{DoxyEnumerate}\\
\hline
\end{DoxyParams}
This can be used for least-\/squares regression tasks. An \hyperlink{classcaffe_1_1InnerProductLayer}{Inner\+Product\+Layer} input to a \hyperlink{classcaffe_1_1EuclideanLossLayer}{Euclidean\+Loss\+Layer} exactly formulates a linear least squares regression problem. With non-\/zero weight decay the problem becomes one of ridge regression -- see src/caffe/test/test\+\_\+gradient\+\_\+based\+\_\+solver.\+cpp for a concrete example wherein we check that the gradients computed for a \hyperlink{classcaffe_1_1Net}{Net} with exactly this structure match hand-\/computed gradient formulas for ridge regression.

(Note\+: \hyperlink{classcaffe_1_1Caffe}{Caffe}, and S\+GD in general, is certainly {\bfseries not} the best way to solve linear least squares problems! We use it only as an instructive example.) 

\subsection{Member Function Documentation}
\index{caffe\+::\+Euclidean\+Loss\+Layer@{caffe\+::\+Euclidean\+Loss\+Layer}!Allow\+Force\+Backward@{Allow\+Force\+Backward}}
\index{Allow\+Force\+Backward@{Allow\+Force\+Backward}!caffe\+::\+Euclidean\+Loss\+Layer@{caffe\+::\+Euclidean\+Loss\+Layer}}
\subsubsection[{\texorpdfstring{Allow\+Force\+Backward(const int bottom\+\_\+index) const }{AllowForceBackward(const int bottom_index) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Dtype $>$ virtual bool {\bf caffe\+::\+Euclidean\+Loss\+Layer}$<$ Dtype $>$\+::Allow\+Force\+Backward (
\begin{DoxyParamCaption}
\item[{const int}]{bottom\+\_\+index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classcaffe_1_1EuclideanLossLayer_a3c954fd7c15596fd2f59e0f79601905c}{}\label{classcaffe_1_1EuclideanLossLayer_a3c954fd7c15596fd2f59e0f79601905c}
Unlike most loss layers, in the \hyperlink{classcaffe_1_1EuclideanLossLayer}{Euclidean\+Loss\+Layer} we can backpropagate to both inputs -- override to return true and always allow force\+\_\+backward. 

Reimplemented from \hyperlink{classcaffe_1_1LossLayer_ad02fe695b06451ac8e6f21db0cba1dad}{caffe\+::\+Loss\+Layer$<$ Dtype $>$}.

\index{caffe\+::\+Euclidean\+Loss\+Layer@{caffe\+::\+Euclidean\+Loss\+Layer}!Backward\+\_\+cpu@{Backward\+\_\+cpu}}
\index{Backward\+\_\+cpu@{Backward\+\_\+cpu}!caffe\+::\+Euclidean\+Loss\+Layer@{caffe\+::\+Euclidean\+Loss\+Layer}}
\subsubsection[{\texorpdfstring{Backward\+\_\+cpu(const vector$<$ Blob$<$ Dtype $>$ $\ast$ $>$ \&top, const vector$<$ bool $>$ \&propagate\+\_\+down, const vector$<$ Blob$<$ Dtype $>$ $\ast$ $>$ \&bottom)}{Backward_cpu(const vector< Blob< Dtype > * > &top, const vector< bool > &propagate_down, const vector< Blob< Dtype > * > &bottom)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Dtype $>$ void {\bf caffe\+::\+Euclidean\+Loss\+Layer}$<$ Dtype $>$\+::Backward\+\_\+cpu (
\begin{DoxyParamCaption}
\item[{const vector$<$ {\bf Blob}$<$ Dtype $>$ $\ast$ $>$ \&}]{top, }
\item[{const vector$<$ bool $>$ \&}]{propagate\+\_\+down, }
\item[{const vector$<$ {\bf Blob}$<$ Dtype $>$ $\ast$ $>$ \&}]{bottom}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classcaffe_1_1EuclideanLossLayer_afc83c3980206b9c24b5985819c13475c}{}\label{classcaffe_1_1EuclideanLossLayer_afc83c3980206b9c24b5985819c13475c}


Computes the Euclidean error gradient w.\+r.\+t. the inputs. 

Unlike other children of \hyperlink{classcaffe_1_1LossLayer}{Loss\+Layer}, \hyperlink{classcaffe_1_1EuclideanLossLayer}{Euclidean\+Loss\+Layer} {\bfseries can} compute gradients with respect to the label inputs bottom\mbox{[}1\mbox{]} (but still only will if propagate\+\_\+down\mbox{[}1\mbox{]} is set, due to being produced by learnable parameters or if force\+\_\+backward is set). In fact, this layer is \char`\"{}commutative\char`\"{} -- the result is the same regardless of the order of the two bottoms.


\begin{DoxyParams}{Parameters}
{\em top} & output \hyperlink{classcaffe_1_1Blob}{Blob} vector (length 1), providing the error gradient with respect to the outputs
\begin{DoxyEnumerate}
\item $ (1 \times 1 \times 1 \times 1) $ This \hyperlink{classcaffe_1_1Blob}{Blob}\textquotesingle{}s diff will simply contain the loss\+\_\+weight$\ast$ $ \lambda $, as $ \lambda $ is the coefficient of this layer\textquotesingle{}s output $\ell_i$ in the overall \hyperlink{classcaffe_1_1Net}{Net} loss $ E = \lambda_i \ell_i + \mbox{other loss terms}$; hence $ \frac{\partial E}{\partial \ell_i} = \lambda_i $. ($\ast$\+Assuming that this top \hyperlink{classcaffe_1_1Blob}{Blob} is not used as a bottom (input) by any other layer of the \hyperlink{classcaffe_1_1Net}{Net}.) 
\end{DoxyEnumerate}\\
\hline
{\em propagate\+\_\+down} & see \hyperlink{classcaffe_1_1Layer_a53df1e081767e07bfb4c81657f4acd0a}{Layer\+::\+Backward}. \\
\hline
{\em bottom} & input \hyperlink{classcaffe_1_1Blob}{Blob} vector (length 2)
\begin{DoxyEnumerate}
\item $ (N \times C \times H \times W) $ the predictions $\hat{y}$; Backward fills their diff with gradients $ \frac{\partial E}{\partial \hat{y}} = \frac{1}{n} \sum\limits_{n=1}^N (\hat{y}_n - y_n) $ if propagate\+\_\+down\mbox{[}0\mbox{]}
\item $ (N \times C \times H \times W) $ the targets $y$; Backward fills their diff with gradients $ \frac{\partial E}{\partial y} = \frac{1}{n} \sum\limits_{n=1}^N (y_n - \hat{y}_n) $ if propagate\+\_\+down\mbox{[}1\mbox{]} 
\end{DoxyEnumerate}\\
\hline
\end{DoxyParams}


Implements \hyperlink{classcaffe_1_1Layer_a64d15855f882af4b82e83fa993c4e7c6}{caffe\+::\+Layer$<$ Dtype $>$}.

\index{caffe\+::\+Euclidean\+Loss\+Layer@{caffe\+::\+Euclidean\+Loss\+Layer}!Forward\+\_\+cpu@{Forward\+\_\+cpu}}
\index{Forward\+\_\+cpu@{Forward\+\_\+cpu}!caffe\+::\+Euclidean\+Loss\+Layer@{caffe\+::\+Euclidean\+Loss\+Layer}}
\subsubsection[{\texorpdfstring{Forward\+\_\+cpu(const vector$<$ Blob$<$ Dtype $>$ $\ast$ $>$ \&bottom, const vector$<$ Blob$<$ Dtype $>$ $\ast$ $>$ \&top)}{Forward_cpu(const vector< Blob< Dtype > * > &bottom, const vector< Blob< Dtype > * > &top)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Dtype $>$ void {\bf caffe\+::\+Euclidean\+Loss\+Layer}$<$ Dtype $>$\+::Forward\+\_\+cpu (
\begin{DoxyParamCaption}
\item[{const vector$<$ {\bf Blob}$<$ Dtype $>$ $\ast$ $>$ \&}]{bottom, }
\item[{const vector$<$ {\bf Blob}$<$ Dtype $>$ $\ast$ $>$ \&}]{top}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classcaffe_1_1EuclideanLossLayer_aa642f3d938b4e1d0c8b240c68ba8a856}{}\label{classcaffe_1_1EuclideanLossLayer_aa642f3d938b4e1d0c8b240c68ba8a856}


Computes the Euclidean (L2) loss $ E = \frac{1}{2N} \sum\limits_{n=1}^N \left| \left| \hat{y}_n - y_n \right| \right|_2^2 $ for real-\/valued regression tasks. 


\begin{DoxyParams}{Parameters}
{\em bottom} & input \hyperlink{classcaffe_1_1Blob}{Blob} vector (length 2)
\begin{DoxyEnumerate}
\item $ (N \times C \times H \times W) $ the predictions $ \hat{y} \in [-\infty, +\infty]$
\item $ (N \times C \times H \times W) $ the targets $ y \in [-\infty, +\infty]$ 
\end{DoxyEnumerate}\\
\hline
{\em top} & output \hyperlink{classcaffe_1_1Blob}{Blob} vector (length 1)
\begin{DoxyEnumerate}
\item $ (1 \times 1 \times 1 \times 1) $ the computed Euclidean loss\+: $ E = \frac{1}{2n} \sum\limits_{n=1}^N \left| \left| \hat{y}_n - y_n \right| \right|_2^2 $
\end{DoxyEnumerate}\\
\hline
\end{DoxyParams}
This can be used for least-\/squares regression tasks. An \hyperlink{classcaffe_1_1InnerProductLayer}{Inner\+Product\+Layer} input to a \hyperlink{classcaffe_1_1EuclideanLossLayer}{Euclidean\+Loss\+Layer} exactly formulates a linear least squares regression problem. With non-\/zero weight decay the problem becomes one of ridge regression -- see src/caffe/test/test\+\_\+gradient\+\_\+based\+\_\+solver.\+cpp for a concrete example wherein we check that the gradients computed for a \hyperlink{classcaffe_1_1Net}{Net} with exactly this structure match hand-\/computed gradient formulas for ridge regression.

(Note\+: \hyperlink{classcaffe_1_1Caffe}{Caffe}, and S\+GD in general, is certainly {\bfseries not} the best way to solve linear least squares problems! We use it only as an instructive example.) 

Implements \hyperlink{classcaffe_1_1Layer_add965883f75bbf90c7a06f960cda7a1a}{caffe\+::\+Layer$<$ Dtype $>$}.

\index{caffe\+::\+Euclidean\+Loss\+Layer@{caffe\+::\+Euclidean\+Loss\+Layer}!Reshape@{Reshape}}
\index{Reshape@{Reshape}!caffe\+::\+Euclidean\+Loss\+Layer@{caffe\+::\+Euclidean\+Loss\+Layer}}
\subsubsection[{\texorpdfstring{Reshape(const vector$<$ Blob$<$ Dtype $>$ $\ast$ $>$ \&bottom, const vector$<$ Blob$<$ Dtype $>$ $\ast$ $>$ \&top)}{Reshape(const vector< Blob< Dtype > * > &bottom, const vector< Blob< Dtype > * > &top)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Dtype $>$ void {\bf caffe\+::\+Euclidean\+Loss\+Layer}$<$ Dtype $>$\+::Reshape (
\begin{DoxyParamCaption}
\item[{const vector$<$ {\bf Blob}$<$ Dtype $>$ $\ast$ $>$ \&}]{bottom, }
\item[{const vector$<$ {\bf Blob}$<$ Dtype $>$ $\ast$ $>$ \&}]{top}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classcaffe_1_1EuclideanLossLayer_a4d2df2fad6e3d04ed24df9fe6460c683}{}\label{classcaffe_1_1EuclideanLossLayer_a4d2df2fad6e3d04ed24df9fe6460c683}


Adjust the shapes of top blobs and internal buffers to accommodate the shapes of the bottom blobs. 


\begin{DoxyParams}{Parameters}
{\em bottom} & the input blobs, with the requested input shapes \\
\hline
{\em top} & the top blobs, which should be reshaped as needed\\
\hline
\end{DoxyParams}
This method should reshape top blobs as needed according to the shapes of the bottom (input) blobs, as well as reshaping any internal buffers and making any other necessary adjustments so that the layer can accommodate the bottom blobs. 

Reimplemented from \hyperlink{classcaffe_1_1LossLayer_ab15b7120ebc172274481f3732db78c9e}{caffe\+::\+Loss\+Layer$<$ Dtype $>$}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/caffe/layers/euclidean\+\_\+loss\+\_\+layer.\+hpp\item 
src/caffe/layers/euclidean\+\_\+loss\+\_\+layer.\+cpp\end{DoxyCompactItemize}
